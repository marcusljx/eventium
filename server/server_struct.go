package server

/* AUTOGENERATED USING grpcgen
 * Only edit if you know what you are doing!
 * For template changes/edits/bugs/new features, please contact marcusljx@gmail.com
 */

import (
	"fmt"
	"log"
	"net"

	"github.com/marcusljx/eventium/eventiumpb"
	"github.com/marcusljx/eventium/server/db"
	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"
)

type eventiumLogic struct {
	data db.DB
}

// StartServer begins the service listener
func StartServer(port int, databaseHandler db.DB) {
	// Set up listener
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		grpclog.Fatalf("Failed to listen: %v", err)
	}

	// // Do transport security (eg.TLS) here if required.
	//
	// var opts []grpc.ServerOption
	// if tls { // <- if TLS is required, this bool variable should be injected (one possibility is to add to StartServer() signature)
	// 		creds, err := credentials.NewServerTLSFromFile(certFile, keyFile)    // <- certFile and keyFile should also be injected
	//  	if err != nil {
	// 			grpclog.Fatalf("Failed to generate credentials %v", err)
	// 		}
	// 		opts = []grpc.ServerOption{grpc.Creds(creds)}
	// }

	// Initialise gRPC layer
	grpcServer := grpc.NewServer()

	// Hook protobuf-created interface to logic handler
	eventiumpb.RegisterEventiumServer(
		grpcServer,
		&eventiumLogic{
			data: databaseHandler,
		},
	)

	// Start service
	grpclog.Printf("Starting server on %s", lis.Addr())

	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("Service quit unexpectedly: %v", err)
	}
}
